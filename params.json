{"name":"Gorequest","tagline":"GoRequest -- Simplified HTTP client ( inspired by nodejs SuperAgent )","body":"GoRequest\r\n=========\r\n\r\nGoRequest -- Simplified HTTP client ( inspired by famous SuperAgent lib in Node.js )\r\n\r\nSending request would never been fun and easier than this. It comes with lots of feature: \r\n\r\n* Get/Post/Put/Head/Delete\r\n* Set - simple header setting \r\n* JSON - made it simple with JSON string as a parameter\r\n* Proxy - sending request via proxy\r\n* Timeout - setting timeout for a request\r\n* RedirectPolicy\r\n* more to come.. \r\n\r\n## Installation\r\n\r\n```bash\r\n$ go get github.com/parnurzeal/gorequest\r\n```\r\n\r\n## Documentation\r\nSee [Go Doc](http://godoc.org/github.com/parnurzeal/gorequest) or [Go Walker](http://gowalker.org/github.com/parnurzeal/gorequest) for usage and details.\r\n\r\n## Status\r\n\r\n[![Drone Build Status](https://drone.io/github.com/jmcvetta/restclient/status.png)](https://drone.io/github.com/parnurzeal/gorequest/latest)\r\n[![Travis Build Status](https://travis-ci.org/parnurzeal/gorequest.svg?branch=master)](https://travis-ci.org/parnurzeal/gorequest)\r\n\r\n## Why should you use GoRequest?\r\n\r\nGoRequest makes thing much more simple for you, making http client more awesome and fun like SuperAgent + golang style usage.\r\n\r\nThis is what you normally do for a simple GET without GoRequest:\r\n\r\n```go\r\nresp, err := http.Get(\"http://example.com/\")\r\n```\r\n\r\nWith GoRequest:\r\n\r\n```go\r\nrequest := gorequest.New()\r\nresp, body, errs := request.Get(\"http://example.com/\").End()\r\n```\r\n\r\nOr below if you don't want to reuse it for other requests.\r\n\r\n```go\r\nresp, body, errs := gorequest.New().Get(\"http://example.com/\").End()\r\n```\r\n\r\nHow about getting control over HTTP client headers, redirect policy, and etc. Things is getting more complicated in golang. You need to create a Client, setting header in different command, ... to do just only one __GET__\r\n\r\n```go\r\nclient := &http.Client{\r\n  CheckRedirect: redirectPolicyFunc,\r\n}\r\n\r\nreq, err := http.NewRequest(\"GET\", \"http://example.com\", nil)\r\n\r\nreq.Header.Add(\"If-None-Match\", `W/\"wyzzy\"`)\r\nresp, err := client.Do(req)\r\n```\r\n\r\nWhy making things ugly while you can just do as follows:\r\n\r\n```go\r\nrequest := gorequest.New()\r\nresp, body, errs := request.Get(\"http://example.com\").\r\n  RedirectPolicy(redirectPolicyFunc).\r\n  Set(\"If-None-Match\", `W/\"wyzzy\"`).\r\n  End()\r\n```\r\n\r\n__DELETE__, __HEAD__, __POST__, __PUT__ are now supported and can be used the same way as __GET__:\r\n\r\n```go\r\nrequest := gorequest.New()\r\nresp, body, errs := request.Post(\"http://example.com\").End()\r\n// PUT -> request.Put(\"http://example.com\").End()\r\n// DELETE -> request.Delete(\"http://example.com\").End()\r\n// HEAD -> request.Head(\"http://example.com\").End()\r\n```\r\n\r\n### JSON\r\n\r\nFor a __JSON POST__ with standard libraries, you might need to marshal map data structure to json format, setting header to 'application/json' (and other headers if you need to) and declare http.Client. So, you code become longer and hard to maintain:\r\n\r\n```go\r\nm := map[string]interface{}{\r\n  \"name\": \"backy\",\r\n  \"species\": \"dog\",\r\n}\r\nmJson, _ := json.Marshal(m)\r\ncontentReader := bytes.NewReader(mJson)\r\nreq, _ := http.NewRequest(\"POST\", \"http://example.com\", contentReader)\r\nreq.Header.Set(\"Content-Type\", \"application/json\")\r\nreq.Header.Set(\"Notes\",\"GoRequest is coming!\")\r\nclient := &http.Client{}\r\nresp, _ := client.Do(req)\r\n```\r\n\r\nCompared to our GoRequest version, JSON is for sure a default. So, it turns out to be just one simple line!:\r\n\r\n```go\r\nrequest := gorequest.New()\r\nresp, body, errs := request.Post(\"http://example.com\").\r\n  Set(\"Notes\",\"gorequst is coming!\").\r\n  Send(`{\"name\":\"backy\", \"species\":\"dog\"}`).\r\n  End()\r\n```\r\n\r\nMoreover, it also supports struct type. So, you can have a fun __Mix & Match__ sending the different data types for your request:\r\n\r\n```go\r\ntype BrowserVersionSupport struct {\r\n  Chrome string\r\n  Firefox string\r\n}\r\nver := BrowserVersionSupport{ Chrome: \"37.0.2041.6\", Firefox: \"30.0\" }\r\nrequest := gorequest.New()\r\nresp, body, errs := request.Post(\"http://version.com/update\")\r\n  Send(ver).\r\n  Send(`{\"Safari\":\"5.1.10\"}`).\r\n  End()\r\n```\r\n\r\n## Callback\r\n\r\nMoreover, GoRequest also supports callback function. This gives you much more flexibility on using it. You can use it any way to match your own style!\r\nLet's see a bit of callback example:\r\n\r\n```go\r\nfunc printBody(resp gorequest.Response, body string, errs []error){\r\n  fmt.Println(resp.Status)\r\n}\r\ngorequest.New().Get(\"http://example.com\").End(printBody)\r\n```\r\n\r\n## Proxy\r\n\r\nIn the case when you are behind proxy, GoRequest can handle it easily with Proxy func:\r\n\r\n```go\r\nrequest := gorequest.New().Proxy(\"http://proxy:999\")\r\nresp, body, errs:= request.Get(\"http://example-proxy.com\").End()\r\n// To reuse same client with no_proxy, use empty string:\r\nresp, body, errs= request.Proxy(\"\").(\"http://example-no-proxy.com\").End()\r\n```\r\n\r\n## Timeout\r\n\r\nTimeout can be set in any time duration using time package:\r\n\r\n```go\r\nrequest := gorequest.New().Timeout(2*time.Millisecond)\r\nresp, body, errs:= request.Get(\"http://example.com\").End()\r\n```\r\n\r\n## License\r\n\r\nGoRequest is MIT License.\r\n\r\n\r\n","google":"UA-13298764-3","note":"Don't delete this file! It's used internally to help with page regeneration."}